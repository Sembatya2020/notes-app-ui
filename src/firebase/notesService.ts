import { 
  collection, 
  addDoc, 
  getDocs, 
  deleteDoc, 
  doc, 
  updateDoc,
  onSnapshot,
  query,
  orderBy
} from "firebase/firestore";
import { db } from "./config";

/**
 * Interface defining the structure of a Note document in Firestore
 */
export interface Note {
  id?: string;
  title: string;
  content: string;
  category?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// Reference to the 'notes' collection in Firestore
const notesCollection = collection(db, "notes");

/**
 * Adds a new note to the Firestore database
 * @param note - Note data without ID (ID is auto-generated by Firestore)
 * @returns Promise with the created note including its new ID
 */
export const addNote = async (note: Omit<Note, 'id'>) => {
  try {
    const noteData = {
      ...note,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    const docRef = await addDoc(notesCollection, noteData);
    return { id: docRef.id, ...noteData };
  } catch (error) {
    console.error("Error adding note: ", error);
    throw error;
  }
};

/**
 * Retrieves all notes from Firestore, ordered by creation date (newest first)
 * @returns Promise with array of all notes
 */
export const getNotes = async (): Promise<Note[]> => {
  try {
    const q = query(notesCollection, orderBy("createdAt", "desc"));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Note));
  } catch (error) {
    console.error("Error getting notes: ", error);
    throw error;
  }
};

/**
 * Deletes a note from Firestore using its document ID
 * @param noteId - The unique Firestore document ID of the note to delete
 */
export const deleteNote = async (noteId: string) => {
  try {
    await deleteDoc(doc(db, "notes", noteId));
  } catch (error) {
    console.error("Error deleting note: ", error);
    throw error;
  }
};

/**
 * Updates an existing note in Firestore
 * @param noteId - The unique Firestore document ID of the note to update
 * @param updatedNote - Partial note data with the fields to update
 */
export const updateNote = async (noteId: string, updatedNote: Partial<Note>) => {
  try {
    const noteRef = doc(db, "notes", noteId);
    const updateData = {
      ...updatedNote,
      updatedAt: new Date()
    };
    await updateDoc(noteRef, updateData);
  } catch (error) {
    console.error("Error updating note: ", error);
    throw error;
  }
};

/**
 * Sets up a real-time listener for notes collection changes
 * This enables live updates when notes are added, modified, or deleted
 * @param callback - Function called whenever the notes collection changes
 * @returns Unsubscribe function to stop listening
 */
export const subscribeToNotes = (callback: (notes: Note[]) => void) => {
  const q = query(notesCollection, orderBy("createdAt", "desc"));
  return onSnapshot(q, (querySnapshot) => {
    const notes = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    } as Note));
    callback(notes);
  });
};
